# "sp." 和 "spp."
用于表示物种（species）和物种群（species pluralis）

1. "sp." 是拉丁文 "species" 的缩写，用于表示一个未指定的物种。当我们无法具体确定某个生物的物种时，可以使用 "sp." 来表示该生物属于某个特定属，但不确定其具体物种。

2. "spp." 是拉丁文 "species pluralis" 的缩写，用于表示多个未指定的物种。当我们无法具体确定多个生物的物种时，可以使用 "spp." 来表示它们属于同一属，但各自的物种不确定。

总之，"sp." 和 "spp." 在分类学中用于表示未指定或不确定的物种或物种群。

其他补充：
`genus`: 属（一种分类等级，用于表示生物学中属的概念）

`species`: 种（生物学中表示一个独立的生物种类）

`no rank`: 无等级（表示没有特定的分类等级）

`varietas`: 变种（生物学中表示种内的变异类型）

`strain`: 菌株（微生物学中指特定的细菌、真菌或病毒株系）

`forma`: 变种（生物学中指种内的特定变异类型）

# Perl 的一些内置函数
1. map 函数：
是用于对数组或者列表中的每个元素进行某种操作，并返回一个新的经过操作后的数组或列表。map 函数不会改变原始的数组或列表，它总是返回一个新的数组或列表。

2. chomp 函数： 用于去除字符串末尾的换行符（也可以是其他指定的字符）。
chomp 函数会检查变量或表达式的末尾字符，如果是换行符（\n）、回车符（\r）或回车换行符（\r\n），则移除它们；否则不做任何操作。移除的过程是在原始字符串上进行的，并且返回值是移除的字符数。

需要注意的是，chomp 函数只会移除末尾的换行符，不会处理字符串中间的换行符。如果需要移除字符串中间的换行符，可以使用替换操作，例如 `s/\R//g`。

3. rindex函数： 用于查找字符串中子字符串最后一次出现的位置。

`rindex` 函数的语法如下：
```
rindex EXPR, SEARCHSTR, POSITION
```
其中，`EXPR` 是要搜索的字符串，`SEARCHSTR` 是要查找的子字符串，`POSITION` 是可选参数，表示开始查找的起始位置，默认为字符串末尾。

`rindex` 函数会在 `EXPR` 字符串中从后往前查找 `SEARCHSTR` 子字符串，并返回最后一次出现的位置。如果找到了该子字符串，则返回它在字符串中的索引位置（从 0 开始），如果没有找到，则返回 -1。

下面是一个示例：

```perl
my $str = "Hello, world! Hello again!";
my $pos = rindex($str, "Hello");
print $pos;  # 输出: 17
```

在上述示例中，`rindex($str, "Hello")` 在 `$str` 字符串中从后往前查找最后一次出现的 "Hello" 子字符串，并返回它在字符串中的索引位置，即 17。

需要注意的是，`rindex` 函数区分大小写。如果需要进行不区分大小写的搜索，可以使用其他函数，例如 `index($str, $substr)` 结合正则表达式 `/i` 进行忽略大小写的匹配。

4. index 函数用于搜索字符串中某个子字符串的第一次出现，并返回子字符串的起始位置索引。如果找不到子字符串，则返回-1。


# 正则表达式
1.  `=~` 是 Bash 中的正则表达式匹配运算符。它用于在条件语句中检查字符串是否与某个正则表达式匹配。

具体语法如下：
```
[[ string =~ pattern ]]
```
其中，`string` 是要匹配的字符串，`pattern` 是正则表达式模式。

如果 `string` 匹配了 `pattern`，则条件为真（true），否则条件为假（false）。

请注意，在使用 `=~` 进行正则表达式匹配时，`[[ ... ]]` 是必需的，并且 `pattern` 不需要用引号引起来。

2. `==` 是一个相等性比较运算符，在Perl中用于比较两个数值是否相等。如果相等，则表达式的结果为真（true），否则为假（false）。

需要注意的是，`==` 比较的是数值的值，而不考虑数值类型。所以对于字符串形式的数字，Perl会隐式地将其转换为数值进行比较。

3. `[0-9]+$` :用于检查字符串是否完全由数字组成

具体解释如下：
- `[0-9]` 表示匹配任意一个数字字符。
- `+` 表示要求前面的表达式（即 `[0-9]`）出现一次或多次。
- `$` 表示匹配输入字符串的结尾位置。

因此，正则表达式 `[0-9]+$` 能够匹配满足以下条件的字符串：
- 字符串中只包含数字字符（0-9）。
- 字符串的结尾位置是数字字符。

下面是一些匹配和不匹配的示例：
- 匹配: "123", "4567", "0"
- 不匹配: "abc", "12a", "123\n"


4. Perl正则表达式
详见[此页面](https://www.runoob.com/perl/perl-regular-expressions.html)
- 匹配：m//（还可以简写为//，略去m）

- 替换：s///

- 转化：tr///
  
- \s* 是一个正则表达式模式，在Perl中用于匹配零个或多个空白字符。具体来说，\s 匹配任何空白字符，包括空格、制表符、换行符、回车符等。而 * 则表示匹配前面的元素零次或多次
- \d+：表示匹配一个或多个数字
- \s*lines?：表示匹配零个或多个空白字符，后跟可选的 "line" 或 "lines"。
- .+?：表示匹配至少一个字符，并尽可能少地匹配。


# 三元运算符 `? :` 
是一种条件运算符，也称为三元条件运算符。
它的语法如下：

```
条件表达式 ? 值1 : 值2
```

如果条件表达式为真，则整个表达式的结果为值1；如果条件表达式为假，则整个表达式的结果为值2。

使用三元运算符可以在一行代码中根据条件选择不同的返回值。这种写法可以简洁地表示简单的条件判断，避免使用 if-else 语句时产生冗余的代码。示例：

```perl
my $x = 5;
my $result = $x > 0 ? "Positive" : "Negative";
print $result;  # 输出 "Positive"
```

上述代码将根据变量 `$x` 的值进行判断，如果 `$x` 大于 0，则将结果赋值为字符串 "Positive"，否则赋值为字符串 "Negative"。最后将结果输出。

# `substr()` 是一个字符串函数
它可以取出字符串中的一部分作为新的子串，并返回该子串。

`substr()` 函数的语法如下：
```
substr(string $string, int $start, ?int $length): string|false
```

参数解释：
- `$string`：要处理的字符串。
- `$start`：指定要截取的起始位置。如果是正数，则表示从起始位置开始向后计数；如果是负数，则表示从字符串末尾向前计数。
- `$length`：可选参数，指定要截取的长度。如果未指定，则从起始位置截取到字符串末尾。

返回值：
- 返回截取的子串，如果截取失败则返回 `false`。

例如，假设有字符串 `$str = "Hello, World!"`，使用 `substr($str, 0, 5)` 将返回子串 `"Hello"`，而使用 `substr($str, -6)` 将返回子串 `"World!"`。

# `mlr` 
是一个用于处理、转换和操作文本数据的命令行工具。它提供了丰富的功能，可以进行数据操作、转换、过滤、计算、统计等操作。

以下是 `mlr` 的一些常见用法和功能：

- 读取和写入：`mlr` 可以读取和写入多种格式的文件，如 CSV、TSV、JSON 等。
- 数据处理和转换：`mlr` 支持对数据进行各种处理和转换操作，如重命名字段、选择特定字段、排序数据、合并数据、拆分数据、转置数据等。
- 数据过滤：`mlr` 可以根据条件进行数据过滤，如基于字段值、正则表达式等。
- 数据计算和统计：`mlr` 提供了丰富的函数和操作符，可以执行各种数学和统计计算，如求和、平均值、最大值、最小值、计数等。
- 数据重塑：`mlr` 可以对数据进行重塑和透视操作，如根据某个字段进行分组汇总、行列转换等。
- 格式转换：`mlr` 可以在不同格式之间进行转换，如将数据从 CSV 转换为 JSON、从 JSON 转换为 CSV 等。

# `export -f` 
是一个 Bash shell 命令，用于将一个函数导出为环境变量。

在 Bash shell 中，可以定义函数，并且这些函数默认只在当前 shell 进程中可用。使用 `export -f` 命令可以将一个函数导出到环境变量中，使得该函数对当前 shell 进程及其子进程都可见。

使用 `export -f` 的语法如下：

```
export -f function_name
```

其中 `function_name` 是要导出的函数名称。

导出函数后，其他的子进程或新开的 shell 进程就能够调用这个函数了。这在需要在不同的 shell 进程之间共享函数时很有用。

需要注意的是，`export -f` 命令只适用于 Bash shell，并且只能导出函数，不能导出普通的变量。

# `mv`
 是一个常用的命令行指令，用于将文件或目录移动或重命名。它的用法如下：

```
mv [选项] 源文件或目录 目标文件或目录
```

其中，`源文件或目录` 表示要移动或重命名的文件或目录的路径，`目标文件或目录` 表示移动后的目标路径或重命名后的新名称。

`mv` 命令的一些常见选项包括：

- `-i`：询问是否覆盖已有文件。
- `-f`：强制覆盖已有文件，不进行询问。
- `-n`：不要覆盖已有文件。
- `-u`：仅在源文件比目标文件新或目标文件不存在时才执行移动操作。
- `-v`：显示详细的移动过程信息。

以下是一些使用 `mv` 命令的示例：

1. 将文件移动到另一个目录中：
   ```
   mv file.txt /path/to/destination/
   ```

2. 重命名文件：
   ```
   mv oldfile.txt newfile.txt
   ```

3. 移动目录，并重命名目录：
   ```
   mv directory/ /path/to/new/location/newdirectory/
   ```

请注意，在执行 `mv` 命令时要小心，确保目标路径或名称是正确的，以避免意外覆盖或删除文件。

# touch
`touch` 是一个常用的命令行工具，它用于创建空文件或者修改已存在文件的访问时间和修改时间。下面是 `touch` 命令的基本用法：

```shell
touch [选项] <文件名>
```

常用选项包括：

- `-a`：仅修改访问时间（access time）。
- `-c`：不创建文件，只更改文件的访问时间和修改时间。
- `-m`：仅修改修改时间（modification time）。
- `-d`：<日期时间> 修改文件的访问时间和修改时间为指定的日期时间。
- `-r`：<参考文件> 以指定文件的访问时间和修改时间为基准来修改目标文件的时间。

示例：

1. 创建一个空文件：

   ```shell
   touch filename.txt
   ```

   如果 `filename.txt` 文件不存在，则会创建一个新的空文件；如果文件已经存在，则不会进行任何修改。

2. 修改文件的访问时间和修改时间为当前时间：

   ```shell
   touch -c filename.txt
   ```

   这会更新 `filename.txt` 文件的访问时间和修改时间为当前的时间。

3. 修改文件的访问时间和修改时间为指定的日期时间：

   ```shell
   touch -d "2023-08-21 10:00:00" filename.txt
   ```

   这会将 `filename.txt` 文件的访问时间和修改时间修改为指定的日期时间。

4. 将目标文件的访问时间和修改时间设置为参考文件的时间：

   ```shell
   touch -r reference.txt target.txt
   ```

   这会将 `target.txt` 的访问时间和修改时间设置为 `reference.txt` 的访问时间和修改时间。

请注意，具体的选项和用法可能因操作系统和命令行环境而有所差异。你可以在终端中运行 `man touch` 命令来查看完整的 `touch` 命令的帮助文档。

# xargs 
是一个命令行工具，用于将标准输入的数据作为参数传递给其他命令，并执行相应的操作。

xargs 命令通常与其他命令和管道结合使用。它从标准输入（或指定的文件）接收数据，并将数据分割成适当大小的块，然后将这些块作为参数传递给其他命令来处理。

xargs 最常用的参数是 `-I`，后跟一个占位符。这个占位符会表示将输入的每一行数据替换到命令中的特定位置。

例如，以下命令将会打印出文件夹中所有文件的名称：

```
ls | xargs -I{} echo {}
```

在上述例子中，`ls` 命令列出当前文件夹中的所有文件，并通过管道将结果传递给 `xargs` 命令。`-I{}` 指定了占位符 `{}`，表示将每个文件名依次替换到 `echo` 命令中，并输出文件名。

需要注意的是，xargs 默认以空格作为分隔符，如果输入的数据包含空格或其他特殊字符，可能需要使用其他参数来处理。

# `colsep `
是一个用于设置列分隔符的命令或变量。在这段代码中，colsep 可能是为了指定用于分隔列的字符

# `qw()` 
是 Perl 中的一种特殊语法，用于创建一个不包含空白符的字符串列表。

具体来说，`qw()` 是 `quote word` 的缩写，它将括号内的内容解析为一个由空白符分隔的字符串列表。每个字符串都被视为一个独立的单词，并且不需要使用引号或逗号进行分隔。

以下是一个示例，展示了如何使用 `qw()` 创建字符串列表：

```perl
my @list = qw(apple banana orange);
print join(", ", @list);  # 输出: apple, banana, orange
```

在这个例子中，`qw(apple banana orange)` 创建了一个包含三个元素的字符串列表，其中每个元素都是一个单词。`join()` 函数将列表的元素用逗号和空格连接起来，并将结果打印出来。

可以使用 `qw()` 快速创建大量的字符串列表，而不必显式地使用引号或逗号进行分隔。这在编写代码时可以提高可读性和易用性。